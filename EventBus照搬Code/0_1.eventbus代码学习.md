# 单队列的 订阅，发布，消费的原理

RabbitMQ发布/订阅核心原理

1. 核心概念回顾

```
// 三大要素
Exchange（交换器） ←→ Binding（绑定） ←→ Queue（队列）
       ↑                      ↑                  ↑
   发布消息              路由规则             消费消息
   routingKey          (routingKey)          (多个消费者)
```

2. 单队列模式的数据流程
   A. 发布方（Publisher）

```
// 发布方代码 - 只声明Exchange，不声明Queue
channel.ExchangeDeclare(exchange: "event_bus", type: "direct");

// 发布消息，指定routingKey
channel.BasicPublish(
    exchange: "event_bus",
    routingKey: "OrderStartedIntegrationEvent",  // 事件名作为路由键
    body: message);
```

发布方不需要Queue的原因：

- 发布方只关心"把消息发送到哪里"（Exchange + routingKey）

- 不关心"谁消费消息"（Queue）
  B. 订阅方（Consumer

```
// 订阅方代码 - 声明Exchange AND Queue
channel.ExchangeDeclare(exchange: "event_bus", type: "direct");

// 每个微服务有自己的队列
channel.QueueDeclare(
    queue: "order_service_queue",  // 队列名通常是微服务名
    durable: true);

// 绑定队列到交换器，指定路由键
channel.QueueBind(
    queue: "order_service_queue",
    exchange: "event_bus",
    routingKey: "OrderStartedIntegrationEvent");  // 关心的事件
```

3. 微服务间的实际场景
   假设我们有3个微服务：

- OrderService（订单服务）- 发布订单事件

- InventoryService（库存服务）- 订阅订单事件

- NotificationService（通知服务）- 订阅订单事件

Step 1: 发布订单事件

```
// OrderService 发布事件
public class OrderService
{
    private readonly IEventBus _eventBus;

    public void CreateOrder()
    {
        var orderEvent = new OrderStartedIntegrationEvent
        {
            OrderId = Guid.NewGuid(),
            CustomerId = "123"
        };

        _eventBus.Publish(orderEvent);  // 发送到 "event_bus" Exchange
    }
}
```

Step 2: 各微服务订阅

```
// InventoryService 配置
public class InventoryServiceStartup
{
    private void ConfigureEventBus(IApplicationBuilder app)
    {
        var eventBus = app.ApplicationServices.GetRequiredService<IEventBus>();

        // 订阅订单事件，使用自己的队列
        eventBus.Subscribe<OrderStartedIntegrationEvent, UpdateInventoryHandler>();
        // 内部会创建队列："inventory_service_queue"
    }
}

// NotificationService 配置
public class NotificationServiceStartup
{
    private void ConfigureEventBus(IApplicationBuilder app)
    {
        var eventBus = app.ApplicationServices.GetRequiredService<IEventBus>();

        // 订阅相同的事件，但使用不同的队列
        eventBus.Subscribe<OrderStartedIntegrationEvent, SendNotificationHandler>();
        // 内部会创建队列："notification_service_queue"
    }
}
```

4. RabbitMQ中的实际结构
   发布事件后，RabbitMQ中的状态：

```
Exchange: "event_bus" (direct类型)
│
├── Binding: routingKey = "OrderStartedIntegrationEvent"
│   ├──→ Queue: "inventory_service_queue" (库存服务)
│   │      └── 消费者: UpdateInventoryHandler
│   │
│   └──→ Queue: "notification_service_queue" (通知服务)
│          └── 消费者: SendNotificationHandler
```

5. 关键代码流程详解
   A. 订阅时的绑定过程

```
public void Subscribe<T, TH>() where T : IntegrationEvent
{
    // 1. 获取事件名称
    var eventName = "OrderStartedIntegrationEvent";

    // 2. 创建或获取队列（每个微服务一个）
    // QueueName = Configuration["SubscriptionClientName"]
    // 例如：inventory_service_queue

    // 3. 绑定队列到Exchange
    channel.QueueBind(
        queue: "inventory_service_queue",
        exchange: "event_bus",
        routingKey: eventName);

    // 4. 开始消费
    StartBasicConsume();
}
```

B. 消息分发机制
![alt text](<../5. 消息分发机制.png>)

6.  配置文件中的关键参数

```
// InventoryService的appsettings.json
{
  "SubscriptionClientName": "inventory_service_queue",
  "EventBusConnection": "localhost",
  "EventBusRetryCount": 5
}

// NotificationService的appsettings.json
{
  "SubscriptionClientName": "notification_service_queue",  // 不同的队列名！
  "EventBusConnection": "localhost",  // 相同的RabbitMQ服务器
  "EventBusRetryCount": 5
}
```

7. 完整时序图
   ![alt text](<../6. 消息发布完整时序图.png>)
8. 为什么能实现微服务间通信
   关键点：

共享Exchange：所有微服务连接到同一个Exchange

独立的Queue：每个微服务有自己的Queue，用于接收消息

相同的routingKey：不同微服务用相同routingKey绑定，都能收到消息

竞争消费者：同一微服务的多个实例共享一个Queue

# 我有一个疑问，微服务一，声明了Exchange，然后发布事件时候，指定routingKey了，那另一个微服务 也要声明相同的Exchange，去自己的队列里去消费routingKey指定的信息，我的问题是这两个微服务是如何互相知道想同Exchange的

就是说我需要单独运行起来一个RabbitMQ容器吗，我的微服务 对消息的发布方和 消费方需要绑定到这个 RabbitMQ容器吗，那我现有的代码要如何修改才可以 指定这个RabbitMQ吗

# 答案

是的，你需要单独运行一个RabbitMQ容器或服务！

# 启动RabbitMQ容器

例子：

```
# 启动RabbitMQ容器
docker run -d --name rabbitmq \
  -p 5672:5672 \
  -p 15672:15672 \
  rabbitmq:3-management
```

修改配置读取方式

```
// Startup.cs - 增强配置读取
public void ConfigureServices(IServiceCollection services)
{
    // 读取RabbitMQ连接配置
    var eventBusConnection = Configuration["EventBus:Connection"] ??
                           Configuration["EventBusConnection"] ??
                           "localhost";

    var eventBusUserName = Configuration["EventBus:UserName"] ??
                          Configuration["EventBusUserName"] ??
                          "guest";

    var eventBusPassword = Configuration["EventBus:Password"] ??
                          Configuration["EventBusPassword"] ??
                          "guest";

    var eventBusPort = Configuration.GetValue<int?>("EventBus:Port") ??
                      Configuration.GetValue<int?>("EventBusPort") ??
                      5672;

    if (Configuration.GetValue<bool>("AzureServiceBusEnabled"))
    {
        // Azure Service Bus 配置（保持不变）
    }
    else
    {
        // RabbitMQ 配置（改进版）
        services.AddSingleton<IRabbitMQPersistentConnection>(sp =>
        {
            var logger = sp.GetRequiredService<ILogger<DefaultRabbitMQPersistentConnection>>();

            var factory = new ConnectionFactory()
            {
                HostName = eventBusConnection,  // 使用读取的配置
                Port = eventBusPort,           // 添加端口支持
                UserName = eventBusUserName,
                Password = eventBusPassword,
                DispatchConsumersAsync = true,
                VirtualHost = Configuration["EventBus:VirtualHost"] ?? "/"  // 可选：虚拟主机
            };

            // 配置其他参数
            if (!string.IsNullOrEmpty(Configuration["EventBus:ClientProvidedName"]))
            {
                factory.ClientProvidedName = Configuration["EventBus:ClientProvidedName"];
            }

            var retryCount = Configuration.GetValue<int>("EventBus:RetryCount") ??
                           Configuration.GetValue<int>("EventBusRetryCount") ??
                           5;

            return new DefaultRabbitMQPersistentConnection(factory, logger, retryCount);
        });
    }

    RegisterEventBus(services);
}
```

啊啊，就是这里 初始化DefaultRabbitMQPersistentConnection 的时候，需要指定 RabbitMQ 容器哈，就可以了那我理解了

# 总结

对的！你理解了核心思想：

需要一个中央的RabbitMQ服务（容器或独立服务器）

所有微服务配置相同的连接地址指向这个RabbitMQ

所有微服务使用相同的Exchange名称（硬编码或配置）

每个微服务有自己的队列名称（通常在配置中不同）

一句话总结：

RabbitMQ是消息的"邮局"，所有微服务都去同一个邮局收发信件（消息）

# 那非常可以了，我对于 RabbitMQ 的容器，可不可以用 k8s的概念做到呢，Service 和deployment的概念形成的，

当然可以！而且这正是K8s生产环境的标准做法！ 用K8s部署RabbitMQ比简单的Docker容器更强大、更可靠。

K8s中RabbitMQ的部署架构
![alt text](<../7. K8s中RabbitMQ的部署架构.png>)
