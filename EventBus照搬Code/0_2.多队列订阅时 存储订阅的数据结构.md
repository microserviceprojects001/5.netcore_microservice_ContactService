# 多队列订阅时存储订阅的数据结构

D:\Code\1.microservice\5.netcore_microservice_ContactService\EventBus照搬Code\EventBus\MultiQueueEventBusSubscriptionsManager.cs

```

private readonly Dictionary<string, Dictionary<string, List<SubscriptionInfo>>> _queueHandlers;
数据结构
_queueHandlers = {
    // 高优先级队列
    "high_priority_queue": {
        // OrderStartedIntegrationEvent 事件
        "OrderStartedIntegrationEvent": [
            new SubscriptionInfo {
                IsDynamic = false,
                HandlerType = typeof(HighPriorityOrderStartedHandler)
            },
            new SubscriptionInfo {
                IsDynamic = true,
                HandlerType = typeof(UniversalLoggerEventHandler)
            }
        ],

        // UserCheckoutAcceptedIntegrationEvent 事件
        "UserCheckoutAcceptedIntegrationEvent": [
            new SubscriptionInfo {
                IsDynamic = false,
                HandlerType = typeof(HighPriorityUserCheckoutHandler)
            },
            new SubscriptionInfo {
                IsDynamic = true,
                HandlerType = typeof(UniversalLoggerEventHandler)
            }
        ]
    },

    // 低优先级队列
    "low_priority_queue": {
        // ProductPriceChangedIntegrationEvent 事件
        "ProductPriceChangedIntegrationEvent": [
            new SubscriptionInfo {
                IsDynamic = false,
                HandlerType = typeof(LowPriorityOrderHandler)
            },
            new SubscriptionInfo {
                IsDynamic = true,
                HandlerType = typeof(UniversalLoggerEventHandler)
            }
        ],

        // OrderStartedIntegrationEvent 事件（注意：同一个事件可以在不同队列中有不同处理器）
        "OrderStartedIntegrationEvent": [
            new SubscriptionInfo {
                IsDynamic = false,
                HandlerType = typeof(AnalyticsEventHandler)
            },
            new SubscriptionInfo {
                IsDynamic = true,
                HandlerType = typeof(UniversalLoggerEventHandler)
            }
        ]
    }
}

```

# 代码理解

多队列架构的核心思想
![alt text](<../8. 多队列架构.png>)

# 我的问题是，这个high_priority_queue 和 low_priority_queue的高低优先级是如何体现的呢，在发送和消费时候有什么具体优先级差异吗

很好的问题！你问到关键点了！ 实际上，在你当前的代码中，并没有真正的RabbitMQ优先级机制。让我详细解释并说明如何实现真正的优先级

当前代码的"优先级"只是逻辑上的
当前实现：

❌ 没有真正的消息优先级

❌ 没有优先级队列

✅ 只有逻辑上的队列分离
你的代码已经完美支持同级队列
你的订阅代码实际上就是同级处理

# 结论

你的选择很明智！ 保持同级队列架构：

✅ 避免了优先级带来的复杂度

✅ 系统更稳定，更容易调试
