# EventBus 代码总体工作流程

总结：完整的注册流程

配置连接 → 创建到 RabbitMQ/Service Bus 的持久连接

注册服务 → 将 EventBus 实现、订阅管理器、事件处理器注册到 DI 容器

创建通道 → EventBus 初始化时创建 RabbitMQ 通道、交换机、队列

订阅事件 → 应用启动时建立事件-处理器的映射关系

建立绑定 → 在 RabbitMQ 中建立队列-交换机的绑定关系

开始监听 → 启动消息消费者，等待事件到来

各个微服务确定自己的队列，都在这个单个队列接收信息

# 设计模式的体现

这实际上是中介者模式（Mediator Pattern） 的典型应用：

EventBus 作为中介者

\_handlers 作为路由表

事件发布者不知道谁处理事件

事件处理器不知道谁发布了事件

# 解耦效果：

```
// 发布者只需要关心发布事件
_eventBus.Publish(new ProductPriceChangedIntegrationEvent(...));

// 处理器只需要关心处理事件
public class InventoryServiceHandler : IIntegrationEventHandler<ProductPriceChangedIntegrationEvent>
{
    public Task Handle(ProductPriceChangedIntegrationEvent @event)
    {
        // 处理逻辑...
    }
}
```

#

// Autofac
using (var scope = \_lifetimeScope.BeginLifetimeScope())
{
var service = scope.Resolve<IMyService>();
}

// 内置 DI
using (var scope = \_serviceProvider.CreateScope())
{
var service = scope.ServiceProvider.GetService<IMyService>();
} 我现在就是想理解下这两个的区别

# 涉及思想总结:

1. 订阅时建立映射关系

```
// 这两个调用都在做同一件事：告诉 EventBus "当 ProductPriceChangedIntegrationEvent 发生时..."
eventBus.SubscribeDynamic<UniversalLoggerEventHandler>("ProductPriceChangedIntegrationEvent");
eventBus.Subscribe<ProductPriceChangedIntegrationEvent, ProductPriceChangedIntegrationEventHandler>();

// 它们在 _handlers 字典中创建了这样的映射：
// "ProductPriceChangedIntegrationEvent" ->
//     [UniversalLoggerEventHandler, ProductPriceChangedIntegrationEventHandler]
```

2. 发布时完全解耦

```
// 业务代码只需要关心发布事件，完全不知道谁会处理
public void UpdateProductPrice(int productId, decimal newPrice)
{
    // 业务逻辑...

    // 发布事件：我只关心"发生了什么"，不关心"谁来处理"
    var @event = new ProductPriceChangedIntegrationEvent(productId, oldPrice, newPrice);
    _eventBus.Publish(@event);  // 🚀 发射事件，然后就不用管了
}
```

3. EventBus 自动路由

```
// EventBus 内部自动处理所有路由逻辑
private async Task ProcessEvent(string eventName, string message)
{
    // 自动查找所有订阅者
    var subscriptions = _subsManager.GetHandlersForEvent(eventName);

    // 自动调用所有处理器
    foreach (var subscription in subscriptions)
    {
        // 自动创建处理器实例
        // 自动反序列化消息
        // 自动调用 Handle 方法
    }
}
```

# 这就是"事件驱动架构"的魅力！

发布者完全解耦

```
// 发布者只需要知道"发生了什么事件"
// 完全不知道也不关心：
// - 有多少个处理器
// - 处理器是什么类型（动态/强类型）
// - 处理器在哪里运行
// - 处理器如何实现

_eventBus.Publish(new ProductPriceChangedIntegrationEvent(...));

```

处理器专注单一职责

```
// 每个处理器只关心自己的职责
public class UniversalLoggerEventHandler : IDynamicIntegrationEventHandler
{
    // 我只关心：记录所有事件的通用信息
}

public class ProductPriceChangedIntegrationEventHandler
    : IIntegrationEventHandler<ProductPriceChangedIntegrationEvent>
{
    // 我只关心：处理产品价格变更的业务逻辑
}

public class InventoryUpdateEventHandler
    : IIntegrationEventHandler<ProductPriceChangedIntegrationEvent>
{
    // 我只关心：更新库存
}

// 可以轻松添加新的处理器，完全不影响现有代码
```

系统的可扩展性

```
// 未来可以轻松添加新的处理器，比如：
public class PriceChangeAnalyticsEventHandler
    : IIntegrationEventHandler<ProductPriceChangedIntegrationEvent>
{
    // 新增：价格变更分析
}

public class CustomerNotificationEventHandler
    : IIntegrationEventHandler<ProductPriceChangedIntegrationEvent>
{
    // 新增：客户通知
}

// 添加方式：只需要订阅，发布者代码完全不用修改
eventBus.Subscribe<ProductPriceChangedIntegrationEvent, PriceChangeAnalyticsEventHandler>();
eventBus.Subscribe<ProductPriceChangedIntegrationEvent, CustomerNotificationEventHandler>();
```

# 实际项目中的威力

微服务场景

```
// 订单服务发布事件
public class OrderService
{
    public void CreateOrder(Order order)
    {
        // 创建订单逻辑...
        _eventBus.Publish(new OrderCreatedIntegrationEvent(order.Id));
        // 订单服务只关心创建订单，不关心其他服务怎么反应
    }
}

// 多个服务可以独立订阅这个事件
```

分布式系统

```
// 服务A（.NET）发布事件
_eventBus.Publish(new DataUpdatedIntegrationEvent(data));

// 服务B（Java）可以订阅处理
// 服务C（Python）也可以订阅处理
// 服务D（Go）还可以订阅处理

// 所有服务通过消息中间件（RabbitMQ）解耦
```

# 我虽然大体理解了 设计的原理，但是具体应用还是有差距。我想继续了解一下，应用场景呀，你提到的分布式系统概念我先放一下之后再讨论，不同微服务之间是如何做到的呢，如何发布消息，如何订阅这个消息，如何接受消息
