# 想先讨论一下 这个 client 的个数问题，对于一个项目会有很多个微服务了，那我们一般是每一个微服务一个 client 吗，因为每一个微服务都是有受保护的 API 的

不是按微服务数量来创建客户端，而是按客户端类型来创建。

# 比方说 不同微服务 之间会有自己的 allowscope 呀，像 user.api 的微服务里面，可能会有 user.write ， user.read 的 scope，像通讯录服务 contact.api 的微服务里可能会有 contact.write 等，这些不同微服务的 scope 都会一股脑塞到一个 client 里面吗

正确的做法：按客户端角色和需求分配 Scope

1. 不同客户端类型需要不同的 Scope

```
public static IEnumerable<Client> GetClients()
{
    return new List<Client>
    {
        // 移动应用客户端 - 普通用户使用，只有基本权限
        new Client
        {
            ClientId = "mobile_app",
            ClientName = "Mobile App (User)",
            AllowedGrantTypes = { "sms_code" },
            AllowedScopes =
            {
                "user_api",         // 用户服务：基本访问
                "contact_api",      // 通讯录服务：基本访问
                "user.read",        // 只能读用户信息
                "contact.read",     // 只能读通讯录
                "openid", "profile", "role"
            }
        },

        // Web管理端 - 管理员使用，有完整权限
        new Client
        {
            ClientId = "web_admin",
            ClientName = "Web Admin",
            AllowedGrantTypes = { "authorization_code" },
            AllowedScopes =
            {
                "user_api", "user.read", "user.write", "user.manage",
                "contact_api", "contact.read", "contact.write", "contact.manage", "contact.admin",
                "openid", "profile", "role"
            }
        },

        // 合作伙伴API - 第三方集成，只有有限权限
        new Client
        {
            ClientId = "partner_integration",
            ClientName = "Partner Integration",
            AllowedGrantTypes = { "client_credentials" },
            AllowedScopes =
            {
                "user_api", "user.read",  // 只能读取用户基本信息
                "contact.read"            // 只能读取通讯录
            }
        }
    };
}
```

2. 为每个微服务定义清晰的 API Scope

```
public static IEnumerable<ApiScope> GetApiScopes()
{
    return new List<ApiScope>
    {
        // 用户服务相关的 Scopes
        new ApiScope("user_api", "User API - Basic access"),
        new ApiScope("user.read", "Read user information"),
        new ApiScope("user.write", "Write user information"),
        new ApiScope("user.manage", "Manage users"),
        new ApiScope("user.admin", "User administration"),

        // 通讯录服务相关的 Scopes
        new ApiScope("contact_api", "Contact API - Basic access"),
        new ApiScope("contact.read", "Read contacts"),
        new ApiScope("contact.write", "Write contacts"),
        new ApiScope("contact.manage", "Manage contacts"),
        new ApiScope("contact.admin", "Contact administration"),

        // 网关和其他通用 Scopes
        new ApiScope("gateway_api", "Gateway API access")
    };
}

public static IEnumerable<ApiResource> GetApiResources()
{
    return new List<ApiResource>
    {
        new ApiResource("user_service", "User Service")
        {
            Scopes = { "user_api", "user.read", "user.write", "user.manage", "user.admin" }
        },
        new ApiResource("contact_service", "Contact Service")
        {
            Scopes = { "contact_api", "contact.read", "contact.write", "contact.manage", "contact.admin" }
        },
        new ApiResource("gateway", "API Gateway")
        {
            Scopes = { "gateway_api" }
        }
    };
}

```

3. 遵循最小权限原则
   最小权限原则是安全设计的黄金法则：每个客户端应该只拥有完成其功能所必需的最小权限

```

客户端类型	需要的权限	                                             不应该拥有的权限
移动应用	user.read, contact.read	                                 user.write, contact.write, contact.admin
后台管理	user.read/write/manage, contact.read/write/manage	    -
报表服务	user.read, contact.read	                                user.write, contact.write
数据导入服务	user.write, contact.write	                        user.admin, contact.admin
```

4. 实际场景示例
   场景 1：用户注册流程
   客户端：移动应用 (mobile_app)

所需权限：user.write (创建用户)

不应该有：user.admin (用户管理)

场景 2：管理员修改用户信息
客户端：Web 管理端 (web_admin)

所需权限：user.write, user.manage

不应该有：contact.admin (除非也需要管理通讯录)

场景 3：生成用户报表
客户端：报表服务 (reporting_service)

所需权限：user.read

不应该有：user.write, user.manage 5. 客户端配置的最佳实践

```
// 好的做法：按需分配权限
new Client
{
    ClientId = "mobile_app",
    AllowedScopes =
    {
        "user.read",        // 必要权限
        "contact.read",     // 必要权限
        "openid", "profile" // 身份信息
        // 没有不必要的权限
    }
}

// 坏的做法：分配过多权限
new Client
{
    ClientId = "mobile_app",
    AllowedScopes =
    {
        "user.read", "user.write", "user.manage", "user.admin", // 过多用户权限
        "contact.read", "contact.write", "contact.manage", "contact.admin", // 过多通讯录权限
        "openid", "profile"
        // 这个客户端拥有了它不需要的权限
    }
}
```

# 哈哈，那就是我们平时不会让一个微服务，有自己的 client 了

比方说 移动端 web 应用// 移动应用客户端 - 普通用户使用，只有基本权限

```
 new Client
        {
            ClientId = "mobile_app",
            ClientName = "Mobile App (User)",
            AllowedGrantTypes = { "sms_code" },
            AllowedScopes =
            {
                "user_api",         // 用户服务：基本访问
                "contact_api",      // 通讯录服务：基本访问
                "user.read",        // 只能读用户信息
                "contact.read",     // 只能读通讯录
                "openid", "profile", "role"
            }
        },有自己的 client了， 然后呢public static IEnumerable<ApiResource> GetApiResources()
{
    return new List<ApiResource>
    {
        new ApiResource("user_service", "User Service")
        {
            Scopes = { "user_api", "user.read", "user.write", "user.manage", "user.admin" }
        },
        new ApiResource("contact_service", "Contact Service")
        {
            Scopes = { "contact_api", "contact.read", "contact.write", "contact.manage", "contact.admin" }
        },
        new ApiResource("gateway", "API Gateway")
        {
            Scopes = { "gateway_api" }
        }
    };
}
```

通过 ApiResource 去规范各个微服务的 audience 具备哪些 scope

# 好，那我有下一个问题了哈，我要实现 微服务之间的调用的时候，需要去走 验证逻辑，那此时 client 要如何分布呢

微服务间调用的客户端分布策略
在微服务架构中，推荐使用 "服务客户端"模式。不是每个微服务都有一个客户端，而是为每个需要调用其他服务的微服务创建专门的客户端。

# 我这边的实际情况是 Contact.API 会去调用 User.API 微服务去获取 user 的基本信息，我暂时是用的 user 登录页面获取的 token 给 User.API 微服务发了过去，这样做是不是不太对呀

您意识到了一个非常重要的问题！是的，您当前的做法确实不太对，而且存在安全隐患。
当前做法的问题分析
您现在的做法是：将最终用户的令牌直接传递给另一个微服务。这种方式有几个严重问题：

1. Audience 不匹配

- 用户令牌的 audience 可能是 "contactResource"（发给 Contact.API 的）

- 但 User.API 期望的 audience 是 "user_api"

- 这会导致认证失败或被拒绝

2. 权限过度

- 用户令牌可能包含过多的权限（如 contact.write, contact.admin）

- User.API 不应该获得这些权限，违反了最小权限原则

3. 安全问题

- 如果 User.API 被攻破，攻击者会获得用户令牌

- 令牌可能包含敏感信息或过多权限

4. 追踪和审计困难

- 无法区分是用户直接调用还是 Contact.API 代为调用

- 审计日志会混乱

# 正确的解决方案：使用服务客户端 (没有实践)

您应该使用客户端凭证流程为服务间通信创建专门的令牌：

1. 在 IdentityServer 中添加服务客户端

```
// IdentityServer 配置
new Client
{
    ClientId = "contact_service_client",
    ClientName = "Contact Service Client",
    ClientSecrets = { new Secret("contact_service_secret".Sha256()) },
    AllowedGrantTypes = { "client_credentials" },
    AllowedScopes = { "user_api" }, // 只能访问用户API
    Claims =
    {
        new Claim("client_type", "microservice"),
        new Claim("service_name", "Contact.API")
    }
}
```

2. 创建服务令牌提供者

```
// 在 Contact.API 中创建服务令牌提供者
public interface IServiceTokenProvider
{
    Task<string> GetServiceTokenAsync();
}

public class ServiceTokenProvider : IServiceTokenProvider
{
    private readonly HttpClient _httpClient;
    private readonly IConfiguration _configuration;
    private readonly ILogger<ServiceTokenProvider> _logger;

    public ServiceTokenProvider(
        HttpClient httpClient,
        IConfiguration configuration,
        ILogger<ServiceTokenProvider> logger)
    {
        _httpClient = httpClient;
        _configuration = configuration;
        _logger = logger;
    }

    public async Task<string> GetServiceTokenAsync()
    {
        try
        {
            var discovery = await _httpClient.GetDiscoveryDocumentAsync("https://localhost:5202");
            if (discovery.IsError)
            {
                throw new Exception($"Discovery error: {discovery.Error}");
            }

            var response = await _httpClient.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest
            {
                Address = discovery.TokenEndpoint,
                ClientId = _configuration["ServiceClient:ClientId"],
                ClientSecret = _configuration["ServiceClient:ClientSecret"],
                Scope = "user_api"
            });

            if (response.IsError)
            {
                throw new Exception($"Token request failed: {response.Error}");
            }

            return response.AccessToken;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get service token");
            throw;
        }
    }
}

```

3. 修改您的 UserService

```
public class UserService : IUserService
{
    private readonly IHttpClient _httpClient;
    private readonly IConsulClient _consulClient;
    private readonly ServerDiscoveryConfig _options;
    private readonly IServiceTokenProvider _tokenProvider; // 添加令牌提供者
    private readonly ILogger<UserService> _logger;

    public UserService(
        IHttpClient httpClient,
        IConsulClient consulClient,
        IOptions<ServerDiscoveryConfig> options,
        IServiceTokenProvider tokenProvider, // 注入令牌提供者
        ILogger<UserService> logger)
    {
        _httpClient = httpClient;
        _consulClient = consulClient;
        _options = options.Value;
        _tokenProvider = tokenProvider;
        _logger = logger;
        // 移除 IHttpContextAccessor 依赖
    }

    public async Task<UserIdentity> GetBaseUserInfoAsync(int userId)
    {
        var services = await _consulClient.Health.Service(_options.UserServiceName, tag: null, passingOnly: true);
        var service = services.Response.FirstOrDefault();
        if (service == null)
        {
            throw new Exception($"No healthy instances of {_options.UserServiceName} found");
        }

        var uri = new UriBuilder
        {
            Scheme = service.Service.Tags.Contains("https") ? "https" : "http",
            Host = service.Service.Address,
            Port = service.Service.Port,
            Path = $"/api/users/baseinfo/{userId}"
        }.ToString();

        try
        {
            // 使用服务令牌而不是用户令牌
            var serviceToken = await _tokenProvider.GetServiceTokenAsync();

            var response = await _httpClient.GetStringAsync(uri, serviceToken);

            if (string.IsNullOrEmpty(response))
            {
                return null;
            }

            var userInfo = JsonConvert.DeserializeObject<UserIdentity>(response);
            _logger.LogInformation($"Retrieved user info for ID: {userInfo.UserId}");

            return userInfo;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error calling User.API");
            throw;
        }
    }
}

```

4. 注册依赖关系

```
// Contact.API Program.cs
// 注册HTTP客户端
builder.Services.AddHttpClient("service_token_client", client =>
{
    client.BaseAddress = new Uri("https://localhost:5202"); // IdentityServer地址
});

// 注册服务
builder.Services.AddSingleton<IServiceTokenProvider, ServiceTokenProvider>();
builder.Services.AddScoped<IUserService, UserService>();

// 配置
builder.Services.Configure<ServiceClientSettings>(builder.Configuration.GetSection("ServiceClient"));
```

5. 添加配置

```
// Contact.API appsettings.json
{
  "ServiceClient": {
    "ClientId": "contact_service_client",
    "ClientSecret": "contact_service_secret"
  }
}
```

# 我想了解一下 客户端认证的方式，有什么特点吗，不需要验证 用户的 ，用户名和密码吗，我现在有点不理解这个认证方式的原理了

您问到了一个非常核心的概念！客户端凭证流程（Client Credentials Flow） 确实与您之前熟悉的流程有根本性的不同。让我用一个简单的比喻和详细解释来帮您理解。

```
核心区别：认证的对象不同
认证方式	    认证谁？	          需要什么？	                  好比...
密码/短信认证	用户 (User)	          用户名+密码/手机号+验证码	      员工用工牌进入大楼
客户端凭证流程	应用/服务 (Client)	   Client ID + Client Secret	快递员用工作证进入大楼
```

![alt text](<课程截图/15. 客户端模式认证流程.png>)

客户端凭证流程的特点

1. 无用户参与

```
// 请求示例
POST /connect/token
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id=contact_service_client
&client_secret=contact_service_secret
&scope=user_api
```

- 不需要用户登录

- 不需要用户同意

- 完全自动化

2. 令牌内容不同
   用户令牌：

```
{
  "sub": "123",           // 用户ID
  "name": "张三",         // 用户名
  "role": "User",         // 用户角色
  "scope": "contact.read",
  "aud": "contactResource"
}
```

服务令牌：

```
{
  "client_id": "contact_service_client",  // 客户端ID
  "scope": "user_api",                    // 服务权限
  "aud": "user_api"                       // 目标API
  // 没有用户信息！
}
```

3. 使用场景不同

```
场景	        适用流程
用户登录APP	    授权码流程、密码流程、短信流程
后台任务处理	客户端凭证流程
微服务间调用	客户端凭证流程
定时任务	    客户端凭证流程

```

# 最开始学习的时候有客户端方式获取令牌的 demo 代码
