# 想先讨论一下 这个 client 的个数问题，对于一个项目会有很多个微服务了，那我们一般是每一个微服务一个 client 吗，因为每一个微服务都是有受保护的 API 的

不是按微服务数量来创建客户端，而是按客户端类型来创建。

# 比方说 不同微服务 之间会有自己的 allowscope 呀，像 user.api 的微服务里面，可能会有 user.write ， user.read 的 scope，像通讯录服务 contact.api 的微服务里可能会有 contact.write 等，这些不同微服务的 scope 都会一股脑塞到一个 client 里面吗

正确的做法：按客户端角色和需求分配 Scope

1. 不同客户端类型需要不同的 Scope

```
public static IEnumerable<Client> GetClients()
{
    return new List<Client>
    {
        // 移动应用客户端 - 普通用户使用，只有基本权限
        new Client
        {
            ClientId = "mobile_app",
            ClientName = "Mobile App (User)",
            AllowedGrantTypes = { "sms_code" },
            AllowedScopes =
            {
                "user_api",         // 用户服务：基本访问
                "contact_api",      // 通讯录服务：基本访问
                "user.read",        // 只能读用户信息
                "contact.read",     // 只能读通讯录
                "openid", "profile", "role"
            }
        },

        // Web管理端 - 管理员使用，有完整权限
        new Client
        {
            ClientId = "web_admin",
            ClientName = "Web Admin",
            AllowedGrantTypes = { "authorization_code" },
            AllowedScopes =
            {
                "user_api", "user.read", "user.write", "user.manage",
                "contact_api", "contact.read", "contact.write", "contact.manage", "contact.admin",
                "openid", "profile", "role"
            }
        },

        // 合作伙伴API - 第三方集成，只有有限权限
        new Client
        {
            ClientId = "partner_integration",
            ClientName = "Partner Integration",
            AllowedGrantTypes = { "client_credentials" },
            AllowedScopes =
            {
                "user_api", "user.read",  // 只能读取用户基本信息
                "contact.read"            // 只能读取通讯录
            }
        }
    };
}
```

2. 为每个微服务定义清晰的 API Scope

```
public static IEnumerable<ApiScope> GetApiScopes()
{
    return new List<ApiScope>
    {
        // 用户服务相关的 Scopes
        new ApiScope("user_api", "User API - Basic access"),
        new ApiScope("user.read", "Read user information"),
        new ApiScope("user.write", "Write user information"),
        new ApiScope("user.manage", "Manage users"),
        new ApiScope("user.admin", "User administration"),

        // 通讯录服务相关的 Scopes
        new ApiScope("contact_api", "Contact API - Basic access"),
        new ApiScope("contact.read", "Read contacts"),
        new ApiScope("contact.write", "Write contacts"),
        new ApiScope("contact.manage", "Manage contacts"),
        new ApiScope("contact.admin", "Contact administration"),

        // 网关和其他通用 Scopes
        new ApiScope("gateway_api", "Gateway API access")
    };
}

public static IEnumerable<ApiResource> GetApiResources()
{
    return new List<ApiResource>
    {
        new ApiResource("user_service", "User Service")
        {
            Scopes = { "user_api", "user.read", "user.write", "user.manage", "user.admin" }
        },
        new ApiResource("contact_service", "Contact Service")
        {
            Scopes = { "contact_api", "contact.read", "contact.write", "contact.manage", "contact.admin" }
        },
        new ApiResource("gateway", "API Gateway")
        {
            Scopes = { "gateway_api" }
        }
    };
}

```

3. 遵循最小权限原则
   最小权限原则是安全设计的黄金法则：每个客户端应该只拥有完成其功能所必需的最小权限

```

客户端类型	需要的权限	                                             不应该拥有的权限
移动应用	user.read, contact.read	                                 user.write, contact.write, contact.admin
后台管理	user.read/write/manage, contact.read/write/manage	    -
报表服务	user.read, contact.read	                                user.write, contact.write
数据导入服务	user.write, contact.write	                        user.admin, contact.admin
```

4. 实际场景示例
   场景 1：用户注册流程
   客户端：移动应用 (mobile_app)

所需权限：user.write (创建用户)

不应该有：user.admin (用户管理)

场景 2：管理员修改用户信息
客户端：Web 管理端 (web_admin)

所需权限：user.write, user.manage

不应该有：contact.admin (除非也需要管理通讯录)

场景 3：生成用户报表
客户端：报表服务 (reporting_service)

所需权限：user.read

不应该有：user.write, user.manage 5. 客户端配置的最佳实践

```
// 好的做法：按需分配权限
new Client
{
    ClientId = "mobile_app",
    AllowedScopes =
    {
        "user.read",        // 必要权限
        "contact.read",     // 必要权限
        "openid", "profile" // 身份信息
        // 没有不必要的权限
    }
}

// 坏的做法：分配过多权限
new Client
{
    ClientId = "mobile_app",
    AllowedScopes =
    {
        "user.read", "user.write", "user.manage", "user.admin", // 过多用户权限
        "contact.read", "contact.write", "contact.manage", "contact.admin", // 过多通讯录权限
        "openid", "profile"
        // 这个客户端拥有了它不需要的权限
    }
}
```

# 哈哈，那就是我们平时不会让一个微服务，有自己的 client 了

比方说 移动端 web 应用// 移动应用客户端 - 普通用户使用，只有基本权限

```
 new Client
        {
            ClientId = "mobile_app",
            ClientName = "Mobile App (User)",
            AllowedGrantTypes = { "sms_code" },
            AllowedScopes =
            {
                "user_api",         // 用户服务：基本访问
                "contact_api",      // 通讯录服务：基本访问
                "user.read",        // 只能读用户信息
                "contact.read",     // 只能读通讯录
                "openid", "profile", "role"
            }
        },有自己的 client了， 然后呢public static IEnumerable<ApiResource> GetApiResources()
{
    return new List<ApiResource>
    {
        new ApiResource("user_service", "User Service")
        {
            Scopes = { "user_api", "user.read", "user.write", "user.manage", "user.admin" }
        },
        new ApiResource("contact_service", "Contact Service")
        {
            Scopes = { "contact_api", "contact.read", "contact.write", "contact.manage", "contact.admin" }
        },
        new ApiResource("gateway", "API Gateway")
        {
            Scopes = { "gateway_api" }
        }
    };
}
```

通过 ApiResource 去规范各个微服务的 audience 具备哪些 scope

# 好，那我有下一个问题了哈，我要实现 微服务之间的调用的时候，需要去走 验证逻辑，那此时 client 要如何分布呢

微服务间调用的客户端分布策略
在微服务架构中，推荐使用 "服务客户端"模式。不是每个微服务都有一个客户端，而是为每个需要调用其他服务的微服务创建专门的客户端。
