# 为了让角色信息（role Claim）能够包含在令牌（Token）中，必须在 GetIdentityResources() 方法中显式添加 IdentityResources.Role()

```
public static IEnumerable<IdentityResource> GetIdentityResources()
{
    return new List<IdentityResource>
    {
        new IdentityResources.OpenId(),
        new IdentityResources.Profile(),
        // 新增这一行：确保角色声明（role claim）能包含在令牌里
        new IdentityResources.Role()
    };
}
```

为什么必须添加这个？
这涉及到 IdentityServer 中的一个重要安全概念：声明（Claims）映射和发布。

1. 身份资源（Identity Resource）的定义：

   身份资源代表一个关于用户身份的信息单元，比如用户 ID(openid)、姓名(profile)、角色(role)、邮箱等。

   每个身份资源都预定义了一组会返回的声明类型（Claim Types）。例如：

   IdentityResources.OpenId() -> sub (Subject ID) Claim

   IdentityResources.Profile() -> name, family_name, given_name 等 Claims

   IdentityResources.Role() -> role Claim

2. ApiResource 与 IdentityResource 的区别：

- ApiResource 的 Scopes 定义了客户端（Client）被允许访问什么（AllowedScopes）。

- IdentityResource 定义了允许返回哪些关于用户的身份信息

3. ApiResource 与 IdentityResource 的区别：

- ApiResource 的 Scopes 定义了客户端（Client）被允许访问什么（AllowedScopes）。

- IdentityResource 定义了允许返回哪些关于用户的身份信息。

4. 如何让用户声明进入令牌？

要让像 role 这样的用户声明出现在令牌中，必须满足两个条件：

a. 请求相应的 Scope：客户端在请求令牌时，必须请求包含该声明的 Scope。对于身份声明，就是请求 openid, profile, role 等。

b. 映射身份资源：在 GetIdentityResources() 中声明了 new IdentityResources.Role()，就相当于告诉 IdentityServer：“我有一个叫做 role 的身份资源，如果客户端请求它，我就可以发放 role 声明”

# 简单比喻

- GetIdentityResources() 就像是 IdentityServer 的“信息菜单”。你把 Role() 加入菜单，客户端才能“点餐”（请求 role scope）。

- 客户端在 AllowedScopes 里包含了 role（它已经包含了，因为你有 IdentityServerConstants.StandardScopes.Profile，但显式更好）。

- 你的 ProfileService 或 Validator 是“厨师”，负责准备具体的用户数据（生成包含 role 的 Claims）。

- 最后，role 这道“菜”才能被端上桌（放入 Token）。

# 完整的配置建议

为了确保万无一失，你也可以在客户端的 AllowedScopes 中显式加上 role（虽然 Profile 有时会包含它，但显式更可靠）：

```
public static IEnumerable<Client> GetClients()
{
    return new List<Client>
    {
        new Client
        {
            ClientId = "android",
            // ... 其他配置不变 ...
            AllowedScopes =
            {
                "gateway_api",
                "user_api",
                "contact.read",
                "contact.write",
                "contact.manage",
                "contact.admin",
                IdentityServerConstants.StandardScopes.OpenId,
                IdentityServerConstants.StandardScopes.Profile,
                IdentityServerConstants.StandardScopes.Role, // 显式请求角色信息
                IdentityServerConstants.StandardScopes.OfflineAccess,
            },
        }
    };
}
```

#

{  
 "client_id": "android",
"sub": "3",
"auth_time": 1757114868,
"idp": "local",
"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "John Doe",
"name": "John Doe",
"company": "Example Corp",
"title": "Software Engineer",
"avatar": "default.png",
"jti": "7686057B203045E20AA00561B36AAE3A"
} 这是我的一个 token 了， 其中 claims 添加了 name， company， title， avatar ，我想知道这种 claims 属于哪里的控制呢，属于 new IdentityResources.Profile()吗

## 结论先行

你 Token 中的 name、company、title、avatar 这些 Claims 不属于 IdentityResources.Profile() 的默认映射。

它们是由你的 SmsAuthCodeValidator 和 ProfileService 自定义添加的，属于“额外”或“自定义”的 Claims。IdentityResources.Profile() 只是为它们的发布提供了一个“通道”或“权限”。

# 好就是说我们可以根据客户的请求，动态的控制 返回哪些 claims 加到 token 中哈，

// 2. 自定义逻辑：如果客户端请求了 profile scope，我就额外赠送 company 和 title 信息

    var requestedIdentityResources = context.RequestedResources.IdentityResources.Select(r => r.Name); 这里可以得到客户请求了哪些 scope，然后我们可以返回对应的 claims

# 我想基于角色控制 呢，不同的角色 给返回不同的 claims 信息，这要如何来做呢

基于角色来控制返回的 Claims 是一个非常经典和强大的场景

这可以实现诸如“管理员看到更多字段”、“VIP 用户有特殊标识”等功能。

在你的 ProfileService 中，你可以通过检查用户的角色（role Claim），来动态决定返回哪些额外的 Claims

## 实现步骤

第 1 步：确保角色信息可用
首先，要确保用户的角色信息已经存在于 context.Subject 的 Claims 中。这通常在你的 SmsAuthCodeValidator 中完成：

```
// SmsAuthCodeValidator.cs
// ... 在验证用户之后 ...
var claims = new List<Claim>
{
    new Claim(JwtClaimTypes.Subject, userInfo.Id.ToString()),
    new Claim(JwtClaimTypes.Name, userInfo.Name ?? ""),
    // 添加角色声明 - 假设你从数据库或服务中获取了用户角色
    new Claim(JwtClaimTypes.Role, "User"), // 默认角色
    new Claim(JwtClaimTypes.Role, "PremiumSubscriber"), // 付费用户角色
};
// ... 添加其他业务claims ...
```

第 2 步：在 ProfileService 中实现基于角色的逻辑
接下来，在你的 ProfileService.GetProfileDataAsync 方法中，编写基于角色的控制逻辑：

```
public async Task GetProfileDataAsync(ProfileDataRequestContext context)
{
    var claims = new List<Claim>();
    var subject = context.Subject;

    // 1. 首先，总是包含被明确请求的声明（安全基础）
    claims.AddRange(subject.Claims.Where(claim => context.RequestedClaimTypes.Contains(claim.Type)));

    // 2. 获取用户的所有角色
    var userRoles = subject.FindAll(JwtClaimTypes.Role).Select(c => c.Value).ToList();

    // 3. 基于角色的动态Claims控制
    // 案例1: 如果是管理员，返回敏感的管理信息
    if (userRoles.Contains("Admin"))
    {
        AddAdminClaims(claims, subject);
    }

    // 案例2: 如果是付费用户，返回VIP相关信息和权限
    if (userRoles.Contains("PremiumSubscriber") || userRoles.Contains("VIP"))
    {
        AddPremiumClaims(claims, subject);
    }

    // 案例3: 如果是普通用户，只返回最基本的信息
    if (userRoles.Contains("User") && !userRoles.Any(r => r != "User"))
    {
        // 可以选择性地限制一些信息
        LimitBasicUserClaims(claims);
    }

    // 案例4: 基于特定业务角色的Claims
    if (userRoles.Contains("FinancialAnalyst"))
    {
        claims.Add(new Claim("can_access_financial_reports", "true"));
        claims.Add(new Claim("report_access_level", "detailed"));
    }

    // 4. 设置最终要颁发的声明
    context.IssuedClaims = claims.Distinct(new ClaimTypeComparer()).ToList();

    await Task.CompletedTask;
}
```

第 3 步：实现具体的角色处理逻辑
将不同角色的处理逻辑拆分成独立的方法，让代码更清晰：

```
// 管理员专属Claims
private void AddAdminClaims(List<Claim> claims, ClaimsPrincipal subject)
{
    // 添加管理相关的敏感信息
    claims.TryAddClaim(subject, "internal_employee_id");
    claims.TryAddClaim(subject, "department");
    claims.TryAddClaim(subject, "security_clearance");
    claims.TryAddClaim(subject, "system_access_level");

    // 添加管理权限标识
    claims.Add(new Claim("can_manage_users", "true"));
    claims.Add(new Claim("can_view_audit_logs", "true"));
    claims.Add(new Claim("can_override_limits", "true"));
}

// 付费用户专属Claims
private void AddPremiumClaims(List<Claim> claims, ClaimsPrincipal subject)
{
    // VIP专属信息
    claims.TryAddClaim(subject, "vip_level");
    claims.TryAddClaim(subject, "subscription_end_date");
    claims.TryAddClaim(subject, "personal_account_manager");

    // VIP权限
    claims.Add(new Claim("max_contacts", "1000"));
    claims.Add(new Claim("can_export_data", "true"));
    claims.Add(new Claim("priority_support", "true"));
}

// 限制普通用户的Claims
private void LimitBasicUserClaims(List<Claim> claims)
{
    // 移除普通用户不应该看到的敏感声明
    var sensitiveClaims = claims.Where(c =>
        c.Type == "internal_employee_id" ||
        c.Type == "security_clearance" ||
        c.Type == "vip_level").ToList();

    foreach (var claim in sensitiveClaims)
    {
        claims.Remove(claim);
    }

    // 设置基础用户限制
    claims.Add(new Claim("max_contacts", "100"));
}
```
