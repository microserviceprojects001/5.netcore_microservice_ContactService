# 就跨微服务调用的 认证问题，我想继续讨论一下

# 我们微服务调用时候 授权的时候，由于是 Client 的授权方法，请问能走 RBAC 的方式吗，我不是想走 RBAC 哈，我是想弄清楚概念

您提出了一个非常好的概念性问题。让我们彻底弄清楚在微服务间调用中使用客户端凭证流程时，RBAC（基于角色的访问控制）的适用性和限制
RBAC 的关键特征：

- 以用户为中心

- 通过角色作为中间层

- 角色拥有权限

- 用户被分配角色

2. 客户端凭证流程与 RBAC 的兼容性
   2.1 根本性不匹配
   客户端凭证流程认证的是服务（客户端），而不是用户：

# 我这边之前一直纠结 builder.Services.AddAuthorization(options =>

{
options.AddPolicy("RequireUserApiScope", policy =>
{
policy.RequireAuthenticatedUser();
policy.RequireClaim("scope", "user_api");
});
}); 这个策略逻辑不能在我调用到 [HttpGet("require-user-api-scope")]
[Authorize(Policy = "RequireUserApiScope")]
public IActionResult RequireUserApiScopeEndpoint()
{
var clientId = User.FindFirstValue("client_id");

            return Ok(new
            {
                Message = "这个端点需要 user_api scope",
                ClientId = clientId,
                Timestamp = DateTime.UtcNow
            });
        }
    } 这个方法的时候去执行策略罗，我发现哈，程序启动的时候这个策略逻辑就调用了还会走到policy.RequireAuthenticatedUser();这个方法的，然后呢，如果我把策略名字随意改一下，和方法中的[Authorize(Policy = "RequireUserApiScope")] 不一致，那么RequireUserApiScopeEndpoint 这个方法调用不会成功的，所以所此处的策略定义还是生效的

```
// 这行代码在启动时执行，注册策略
options.AddPolicy("RequireUserApiScope", policy =>
{
    policy.RequireAuthenticatedUser();
    policy.RequireClaim("scope", "user_api");
});
```

您正确注意到，策略的配置逻辑在应用程序启动时执行，而不是在每次请求时执行。这是因为：

- ASP.NET Core 在启动时会构建并编译所有授权策略

- 策略的配置逻辑（如 RequireAuthenticatedUser() 和 RequireClaim()）会被转换为表达式树并编译

- 编译后的策略被缓存以供后续使用

```
options.AddPolicy("RequireUserApiScope", policy =>
       policy.RequireAssertion(context =>
       {
           // 修正：直接从 User 中获取 scope 声明
           var scopeClaims = context.User.FindAll(c => c.Type == "scope");
           var userScopes = scopeClaims.SelectMany(c => c.Value.Split(' ')).ToList();

           // 检查是否包含 user_api scope
           return userScopes.Contains("user_api");
       }));
```

这么写就可以随时调用了

# 我的下一个问题问题是什么呢，[HttpGet("require-user-api-scope")]

        [Authorize(Policy = "RequireUserApiScope")]
        public IActionResult RequireUserApiScopeEndpoint()
        {
            var clientId = User.FindFirstValue("client_id");

            return Ok(new
            {
                Message = "这个端点需要 user_api scope",
                ClientId = clientId,
                Timestamp = DateTime.UtcNow
            });
        } 这个API，我是提供给另一个微服务调用了，那如果用户直接 调用呢，岂不是跟其他的 微服务调用都能使用这个API了吗

这个问题非常靠谱，而且您的考虑完全正确。这确实是一个非常重要且常见的安全隐患，很多系统在设计初期都会忽略这一点。

针对您的情况，我建议新增专门的 Scope
来区分微服务间通信和用户客户端的访问权限。这是最清晰和安全的做法。

# 方案

需要单独建 Client 和 Scope 了，参考代码

# Token

```
{
  "iss": "https://localhost:5202",
  "nbf": 1757847578,
  "iat": 1757847578,
  "exp": 1757851178,
  "aud": "user_api",
  "scope": [
    "user_api.internal"
  ],
  "client_id": "contact_service_client",
  "client_client_type": "microservice",
  "client_service_name": "Contact.API",
  "jti": "92BD05179CBA93A05DC86589B43B997D"
}

```

关键信息：
scope: ["user_api.internal"] - 正确包含了我们定义的内部 scope

client_id: "contact_service_client" - 正确的客户端 ID

client_client_type: "microservice" - 客户端类型声明（注意前缀）

client_service_name: "Contact.API" - 服务名称声明（注意前缀）

注意声明前缀问题
您会注意到客户端声明（client*type 和 service_name）在令牌中被添加了 client* 前缀，变成了 client_client_type 和 client_service_name。这是 IdentityServer 的默认行为。

# 好嘞，现在 client 认证方式实现微服务之间的调用，应该是完全可以实现了，那我下一个问题呀 ClientId = "contact_service_client", 这个 client 只能微服务之间调用时候申请 token 所用，那我能禁止用户登录系统时候用这个 API 去申请 token 吗，正常即使用户用这个 client 注册了 token，拿这个 token 也访问不到 API 哈。或者说，我不想让用户接触这个 Client

保护微服务专用客户端的安全措施
您提出了一个非常重要的安全问题。确实，您希望确保 contact_service_client 这个客户端只能用于微服务间通信，而不能被最终用户直接使用。

a) 使用客户端凭据流（您已经实现）
客户端凭据流(client_credentials)本身就设计用于服务到服务的通信，不需要用户交互。这是第一道防线。

b) 添加额外的客户端约束

```
new Client
{
    ClientId = "contact_service_client",
    ClientName = "Contact Service Client",
    ClientSecrets = { new Secret("contact_service_secret".Sha256()) },
    AllowedGrantTypes = { "client_credentials" },
    AllowedScopes = { "user_api.internal" },

    // 添加这些额外约束
    RequireClientSecret = true, // 必须提供客户端密钥
    RequirePkce = false,        // 不需要PKCE（仅用于授权码流）
    AllowOfflineAccess = false, // 不允许离线访问（不需要刷新令牌）
    AllowAccessTokensViaBrowser = false, // 不允许通过浏览器获取访问令牌

    Claims =
    {
        new ClientClaim("client_type", "microservice"),
        new ClientClaim("service_name", "Contact.API")
    },
    ClientClaimsPrefix = "",
    AlwaysSendClientClaims = true,
    AccessTokenLifetime = 3600
}
```

# ClientSecrets = { new Secret("contact_service_secret".Sha256()) }, 也是一个保护吗，我们确保这个秘钥不要泄露出去就可以

是的，ClientSecrets 是一个非常重要的保护层
您完全正确！ClientSecrets = { new Secret("contact_service_secret".Sha256()) } 是一个关键的安全保护措施。让我详细解释这个机制如何工作以及为什么它如此重要：

使用环境变量或密钥管理服务
在开发环境中使用环境变量

在生产环境中使用专业的密钥管理服务（如 Azure Key Vault、AWS Secrets Manager、HashiCorp Vault）
