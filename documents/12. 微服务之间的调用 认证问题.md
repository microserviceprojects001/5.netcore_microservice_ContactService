# 就跨微服务调用的 认证问题，我想继续讨论一下

# 我们微服务调用时候 授权的时候，由于是 Client 的授权方法，请问能走 RBAC 的方式吗，我不是想走 RBAC 哈，我是想弄清楚概念

您提出了一个非常好的概念性问题。让我们彻底弄清楚在微服务间调用中使用客户端凭证流程时，RBAC（基于角色的访问控制）的适用性和限制
RBAC 的关键特征：

- 以用户为中心

- 通过角色作为中间层

- 角色拥有权限

- 用户被分配角色

2. 客户端凭证流程与 RBAC 的兼容性
   2.1 根本性不匹配
   客户端凭证流程认证的是服务（客户端），而不是用户：

# 我这边之前一直纠结 builder.Services.AddAuthorization(options =>

{
options.AddPolicy("RequireUserApiScope", policy =>
{
policy.RequireAuthenticatedUser();
policy.RequireClaim("scope", "user_api");
});
}); 这个策略逻辑不能在我调用到 [HttpGet("require-user-api-scope")]
[Authorize(Policy = "RequireUserApiScope")]
public IActionResult RequireUserApiScopeEndpoint()
{
var clientId = User.FindFirstValue("client_id");

            return Ok(new
            {
                Message = "这个端点需要 user_api scope",
                ClientId = clientId,
                Timestamp = DateTime.UtcNow
            });
        }
    } 这个方法的时候去执行策略罗，我发现哈，程序启动的时候这个策略逻辑就调用了还会走到policy.RequireAuthenticatedUser();这个方法的，然后呢，如果我把策略名字随意改一下，和方法中的[Authorize(Policy = "RequireUserApiScope")] 不一致，那么RequireUserApiScopeEndpoint 这个方法调用不会成功的，所以所此处的策略定义还是生效的

```
// 这行代码在启动时执行，注册策略
options.AddPolicy("RequireUserApiScope", policy =>
{
    policy.RequireAuthenticatedUser();
    policy.RequireClaim("scope", "user_api");
});
```

您正确注意到，策略的配置逻辑在应用程序启动时执行，而不是在每次请求时执行。这是因为：

- ASP.NET Core 在启动时会构建并编译所有授权策略

- 策略的配置逻辑（如 RequireAuthenticatedUser() 和 RequireClaim()）会被转换为表达式树并编译

- 编译后的策略被缓存以供后续使用

```
options.AddPolicy("RequireUserApiScope", policy =>
       policy.RequireAssertion(context =>
       {
           // 修正：直接从 User 中获取 scope 声明
           var scopeClaims = context.User.FindAll(c => c.Type == "scope");
           var userScopes = scopeClaims.SelectMany(c => c.Value.Split(' ')).ToList();

           // 检查是否包含 user_api scope
           return userScopes.Contains("user_api");
       }));
```

这么写就可以随时调用了

# 我的下一个问题问题是什么呢，[HttpGet("require-user-api-scope")]

        [Authorize(Policy = "RequireUserApiScope")]
        public IActionResult RequireUserApiScopeEndpoint()
        {
            var clientId = User.FindFirstValue("client_id");

            return Ok(new
            {
                Message = "这个端点需要 user_api scope",
                ClientId = clientId,
                Timestamp = DateTime.UtcNow
            });
        } 这个API，我是提供给另一个微服务调用了，那如果用户直接 调用呢，岂不是跟其他的 微服务调用都能使用这个API了吗
