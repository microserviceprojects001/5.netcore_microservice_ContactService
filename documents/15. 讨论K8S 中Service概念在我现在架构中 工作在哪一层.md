# 那我现在已经清处这个流程了 浏览器 ->MVC web 应用 -> API 网关-> User API 各种微服务， 这是基本的流程了哈，好嘞，那我想问一些关于 K8S 里的概念呀，我已经学习过 K8S 中有 Deployment ，Service， Ingress 的概念，我理解我现在的微服务将来就会被部署成为 Deployment Container 的，那 Service 如何应用呢，如何跟我的 API 网关 ，web 应用概念集成的呢，我想象不到了

## 那好，我们就先着重讨论 K8S Service，如果要应用到我系统中，处于那一层在工作，你的意思是说他是工作在 我的 API 网关 和 User.API(例如) 之间吗

是的，Kubernetes Service 正是工作在您的 API 网关 和 User.API（以及其他所有微服务）之间。

它充当着一个透明的中间层，但这个中间层不是您的业务代码，而是 Kubernetes 基础设施的一部分。让我用一个更清晰的层次图来展示：
各层详细说明
![alt text](<课程截图/18. K8S Service工作层.png>)

## 第 1 层：API 网关 (您的应用程序)

角色：流量路由器、统一入口

关注点：”这个请求应该转发到哪个微服务？“

配置示例：在 Ocelot 的 configuration.json 中定义路由规则

通信方式：通过 HTTP 调用下游服务

## 第 1.5 / 2.5 层：Kubernetes Service (基础设施)

角色：服务注册表、负载均衡器、稳定端点提供者

关注点：”当前有哪些健康的 Pod 实例？如何均衡地分发请求？“

配置示例：K8S YAML 文件中定义 Selector 和端口

通信方式：通过 iptables/IPVS 规则操作网络流量

## 第 2 层：业务微服务 (您的应用程序)

角色：实际处理业务逻辑

关注点：”如何处理这个用户查询？如何保存这个联系人？“

配置示例：您的 .NET Core 应用程序代码

通信方式：监听端口，处理 HTTP 请求

## 具体的工作流程

当一次 API 调用发生时：

1. 外部请求 GET /users/123 到达 API 网关 Pod。
2. 网关路由决策：网关根据配置规则判断，这个请求需要被路由到 User.API 的 /api/users/123 端点

```
// 网关的配置规则
{
  "DownstreamPathTemplate": "/api/users/{id}",
  "DownstreamHostAndPorts": [ { "Host": "user-api-service", "Port": 80 } ],
  "UpstreamPathTemplate": "/users/{id}",
  "UpstreamHttpMethod": [ "GET" ]
}
```

3. 服务发现查询：网关需要解析 user-api-service。在 K8S 集群内，这是一个标准的域名。网关会向集群的 DNS 服务（通常是 CoreDNS）发起查询：”user-api-service 的 IP 地址是什么？“
4. 获取稳定端点：DNS 返回一个稳定的虚拟 IP (VIP)，例如 10.103.22.45。这个 VIP 由 user-api-service Service 资源所有，永远不变。
5. 发送请求：网关向 http://10.103.22.45/api/users/123 发送 HTTP 请求。
6. Service 的负载均衡魔法：

- 请求到达 Service 的虚拟 IP。
- Service 根据其内置的负载均衡算法（如轮询），从所有标签为 app: user-api 的健康 Pod 列表中选择一个，例如 Pod IP 10.244.1.2。
- Service 通过修改网络规则（iptables/IPVS），将目标地址为 10.103.22.45:80 的报文，自动转发（DNAT）到 10.244.1.2:80。

7. 请求处理：请求最终到达运行在 10.244.1.2 上的 User.API Pod 实例，该实例处理请求并返回响应。响应则沿着原路返回。

关键要点

1. 解耦：API 网关不需要知道也不关心 User.API 有多少个副本、它们的 IP 是什么、在哪里运行。它只认一个永远不变的 Service 名称和虚拟 IP。
2. 弹性：如果 User.API 的一个 Pod 崩溃了，Kubernetes 会终止它并启动一个新 Pod（新 IP）。Service 会自动从自己的端点列表中移除旧的、不健康的 Pod，加入新的 Pod。这个过程对网关完全透明，网关不需要做任何修改或重启。
3. 可扩展性：当您需要扩容 User.API 时，只需一条命令：kubectl scale deployment/user-api-deployment --replicas=5。Service 会自动发现新增的 3 个 Pod 并将流量分摊给它们。网关依然无需任何更改。

## 所以，您的理解完全正确：Service 是工作在网关和微服务之间的关键基础设施层，它通过提供服务发现和负载均衡能力，使您的微服务架构变得真正具有弹性和可扩展性。您作为开发者，主要与第 1 层和第 2 层（应用层）打交道，而 Kubernetes 帮您管理了第 1.5 和 2.5 层（基础设施层）的复杂性。

![alt text](<课程截图/19. K8S Service工作层.png>)
