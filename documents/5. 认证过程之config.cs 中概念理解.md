# 需要理解的问题

1. Identity server 中 Config.cs 中配置的理解

2. 认证过程的理解

- 首先需要带着 client， secret， scope 等信息去申请 token
  拿到 token 后，API 需要携带 token 去发送请求，此时都是怎么去验证的，
  包括 Gateway 的验证，和 API Server 的验证，都是如何验证的.

401 网关没认证过去
403 是 API 没认证过去

# 开始理解认证过程

现在我的微服务已经开发了一些 出来，包括 User.API, Contact.API, User.Identity Gate way,我现在想捋顺一下认证过程，config.cs 我想对这里定义的概念有一个理解，先说 GetClients()方法这里定义的就是一个一个的 client 吗，是一个大的概念，比方说简书用微信区认证登录，那简书就是一个 client，然后有他自己的 好多个 AllowedScopes

1. Client（客户端）
   您的理解完全正确：Client 就是第三方应用程序
   例子：简书用微信登录 → 简书就是 Client
   在您的系统中：android 就是一个客户端，代表移动端应用

# Client 定义了哪些 scope ，必须要在 GetApiScopes 有与之对应的定义哈

您说得完全正确！这是一个非常重要的概念。
关键规则
一一对应：Client 的 AllowedScopes 中的每个自定义 scope 都必须在
GetApiScopes()
中有对应的定义

标准 scope 例外：openid, profile, offline_access 等是 IdentityServer 的标准 scope，不需要在
GetApiScopes()
中定义

验证机制：如果 Client 请求了未在
GetApiScopes()
中定义的 scope，IdentityServer 会拒绝该请求

# new ApiScope("gateway_api", "My API Scope"), 这个定义有什么具体含义吗，第二个参数 是描述吗

是的，您理解得完全正确！

1. 第一个参数 ("gateway_api")：Scope 的唯一标识符

这是必须的，用于在系统中唯一标识这个 scope
Client 请求和 API 验证时都使用这个标识

2. 第二个参数 ("My API Scope")：显示名称/描述

这是可选的，用于在同意屏幕等用户界面上显示
给用户看的友好名称，说明这个 scope 的用途

# 你的意思是说第二个参数是 consent 授权页面上 会显示的吗

是的，您理解得完全正确

```
new ApiScope("gateway_api", "My API Scope")
```

第一个参数 ("gateway_api")：系统内部使用的技术标识
第二个参数 ("My API Scope")：在同意屏幕(consent screen)上显示给用户的友好描述

## 效果

应用程序 "Android App" 请求访问：

☑️ My API Scope - 访问网关 API 服务  
☑️ my contact scope - 管理联系人信息
☑️ user_api scope - 访问用户数据

[同意] [拒绝]

# 那其中 GetApiResource 是是你用途呢，这个似乎是旧版本 dotnet 里没有这个概念

```
public static IEnumerable<ApiResource> GetApiResource()
{
    return new List<ApiResource>
    {
        new ApiResource("gateway_api", "user api service")
        {
            Scopes = { "gateway_api" }  // 关联到 ApiScope
        },
        new ApiResource("contact_api", "contact service")
        {
            Scopes = { "contact_api" }
        },
        new ApiResource("user_api", "user api") {
            Scopes = { "user_api" }
        }
    };
}
```

# ApiResource 是一个比较大的概念，而 ApiScope 是小得概念吗

您的理解完全正确！👍

很好的比喻理解：
🏢 ApiResource - 大楼

- 代表一个完整的 API 服务（如一栋办公大楼）

- 定义了"这是什么服务"（如联系人管理服务）

- 在令牌中作为 aud（观众）出现，表示"这个令牌可以进入这栋大楼"

- 例子：contactResource（联系人管理大楼）

🚪 ApiScope - 房间权限

- 代表具体的操作权限（如大楼里的各个房间）

- 定义了"可以在这个服务里做什么"（如读取联系人、管理请求）

- 在令牌中作为 scope 声明出现，表示"可以进入哪些房间"

- 例子：contact.read（可以进入阅读室）、contact.manage（可以进入管理室）

# 好，比方说我用 postman 发送请求 去得到令牌了，请求中会有 Client， secret， Scope 参数，我想问 scope 参数里填的 contact_api ，和我们刚刚讨论得概念是和谁对应的呢

scope 参数里填的 contact_api 对应的是我们讨论的 ApiScope（小概念/房间权限）。

# options.ApiName = "contactResource"; // ← 这里使用大楼名称！就是说启动配置中 需要改成这样，那当我用 postman 去请求令牌的时候，有什么特定参数需要设定吗

当您在 Postman 中请求令牌时，不需要直接指定大楼名称（ApiResource）！IdentityServer 会自动帮您关联。

🎯 1. 在 API 项目中验证令牌时使用

```
// Startup.cs 或 Program.cs
services.AddAuthentication("Bearer")
    .AddIdentityServerAuthentication(options =>
    {
        options.Authority = "https://your-identity-server.com";
        options.ApiName = "contactResource";  // ← 这里使用大楼名称！
        options.RequireHttpsMetadata = false;
    });
```

作用：告诉 API 只接受针对"contactResource"这座大楼的令牌。
🎯 2. 在颁发的访问令牌中作为 audience， 当 IdentityServer 颁发令牌时，会自动包含：

```
{
  "access_token": "eyJhbGciOiJ...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "contact.read contact.write",
  // 令牌内部包含：
  // "aud": "contactResource",    ← 大楼名称
  // "scope": "contact.read contact.write"  ← 房间权限
}
```

🎯 3. API 的权限验证流程

```
// 伪代码表示验证过程
public bool ValidateToken(string token)
{
    // 1. 检查令牌是否是给"contactResource"大楼的？
    if (token.aud != "contactResource")
    {
        return false; // 错误大楼，拒绝访问！
    }

    // 2. 检查是否有进入特定房间的权限？
    if (requiredScope == "contact.read" && !token.scopes.Contains("contact.read"))
    {
        return false; // 没有这个房间的权限！
    }

    return true; // 验证通过！
}
```

# 那我基本理解了，我这里之所以 postman 发送的 scope 参数是带有 contact_api 的这个其实 scope，这时候拥有这个 scope 的大楼恰好也叫做 contact_api 我的大楼验证恰好是也是 contact_api ，所以我这恰好没有问题了

# 4. 授权策略配置 是什么

就是说 API 方法头上指定策略 policy

```
[Authorize(Policy = "Contact.Read")] // 需要读取权限
public IActionResult GetContacts() { ... }
```

就会应用

```
options.AddPolicy("Contact.Read", policy =>
policy.RequireAssertion(context =>
context.User.HasClaim(c =>
c.Type == "scope" &&
(c.Value == "contact_api" || c.Value == "contact.read" ||
c.Value == "contact.manage" || c.Value == "contact.admin")
)));
```

这个策略定义了呗

# 问题 403

我现在对 Contact.API 做了一些权限认证的操作， 包括 IdentityServer 中的修改 , 中加了策略标签， 修改了 Audience 加了策略， 然后呢我去请求了 token，是

```
{

"iss": "https://localhost:5202",

"nbf": 1757027664,

"iat": 1757027664,

"exp": 1757031264,

"aud": [

    "contactResource",

    "gateway_api",

    "user_api"

],

"scope": [

    "contact.read",

    "gateway_api",

    "openid",

    "profile",

    "user_api"

],

"amr": [

    "sms_code"

],

"client_id": "android",

"sub": "3",

"auth_time": 1757027664,

"idp": "local",

"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "John Doe",

"name": "John Doe",

"company": "Example Corp",

"title": "Software Engineer",

"avatar": "default.png",

"jti": "DCD158FA4C68B169426E4645D37F6C7E"

}
```

看返回的 aud 没啥问题 有 contactResource，scope 也有 "contact.read", 我遇到的问题是 当我用这个 token 去请求 API 的时候报错 403 呢，你帮我分析一下原因呗

网关报错信息
ScopeNotAuthorizedError: no one user scope: 'contact.read,gateway_api,openid,profile,user_api' match with some allowed scope: 'contact_api'
Setting error response for request: GET /contacts

# 方案

这个错误是网关报出来的，
原因是 ocelot 的配置问题

```
 {
      "DownstreamPathTemplate": "/api/contacts",
      "DownstreamScheme": "https",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5204
        }
      ],
      "UpstreamPathTemplate": "/contacts",
      "UpstreamHttpMethod": [ "GET" ],
      "AuthenticationOptions": {
        "AuthenticationProviderKey": "finbook"
      },
      "RouteClaimsRequirement": {
        "scope": "contact_api"
      }
    },
```

scope --> contact.read

```
"RouteClaimsRequirement": {
        "scope": "contact.read"
      }
```

# 问题 修改了一下 ocelot.json 不报 403 了，但是 audience 认证不过去

System.InvalidOperationException: The AuthorizationPolicy named: 'contactResource' was not found.
at Microsoft.AspNetCore.Authorization.AuthorizationPolicy.CombineAsync(IAuthorizationPolicyProvider policyProvider, IEnumerable`1 authorizeData, IEnumerable`1 policies)
at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)

# 方案

策略里需要加

````

options.AddPolicy("contactResource", policy =>
policy.RequireAssertion(context =>
{
var audienceClaims = context.User.FindAll(c => c.Type == "aud");
return audienceClaims.Any(c => c.Value == "contactResource");
}));

```


